## Давным давно в одной...
!UWAGA! Не предназначено для программистов и прочих красноглазых

Сегодня я попробую рассказать о регулярных выражениях, одном из наиболее мощных инструментов для поиска
и автозамены в текстах. Подобные задачи возникают не так редко, как кажется. Кто недавно делал нечто подобное:

![alt text](regex_img/find_and_replace.png "Поиск и замена")

```sql
SELECT * FROM payments WHERE purpose LIKE "%налог%"
```

```bash
rm -rf todo*
```
Во всех примерах задаются шаблоны для сопоставления с текстом. В первом примере ищутся все вхождения шаблона
в текст и заменяются на другой шаблон. Во втором sql запрос выведет все строки таблицы, в которых
значение колонки purpose cоответствует шаблону целиком (т.е. содержит слово `налог`. В третьем
будут удалены файлы и папки, название которых целиком соответствует шаблону (т.е. начинается с `todo`)

Регулярные выражения как раз и представляют собой язык для задания подобных шаблонов, только более развитый.
Поэтому они позволяют накладывать более точные ограничения на искомый текст и решать более широкий круг
задач. Основные операции те же:
- *rlike / matches* - полное совпадение строки с шаблоном
- *find и findAll* - поиск вхо ждений шаблона в строке
- *replace и replaceAll* - замена найденных вхождений на другой шаблон

Перейдем к синтаксису. Любое слово представляет собой готовое регулярное выражение:
[простой шаблон](https://regex101.com/r/3Kt1rU/1).
Здесь уже используется первая операция: конкатенация (зацепление), соединяющая отдельные символы в шаблон.

Чаще, однако, приходится искать не просто определенное слово но и все его возможные формы.
Для этого понадобится операция `|` - "или" (чередование).
[Словоформы в шаблоне](https://regex101.com/r/b0Cp1r/1).
Приоритет чередования ниже, чем у зацепления. Поэтому необходимо использовать скобки
Обратите внимание, что шаблон применяется
слева направо. Если поменять "о" и "ом" местами, то матчинг успешно закончится на букве "о", а "м"
в результат матча не войдет, что нежелательно.
[Практикум - словоформы](https://regex101.com/r/mUDIP8/1).
[Практикум - даты](https://regex101.com/r/FlUbvY/1)

Попробуем теперь написать регулярное выражение для поиска номеров телефона.
[Телефон](https://regex101.com/r/Kb1q0T/1). Выражение получается очень большим.
Не хватает чего-то похожего на умножение / повторение существующего шаблона.
В РВ для этого существуют *кванторы* или *квантификаторы*:
- `*` - повторение шаблона 0 и более раз
- `+` - 1 и более раз
- `?` - 0 или 1
- `{n}` - ровно n раз
- `{n,}` - n раз или более
- `{n,m}` - от n до m раз
- `{,n}` - от 0 до n раз

Квантор следует за повторяемым шаблоном. [Практикум - числа в тексте](https://regex101.com/r/DlJ9G1/1).
Данные кванторы являются жадными

При большом количестве альтернативных символов регулярное выражения могут стать очень громоздкими.
Эту проблему решают символьные классы. Они записываются в `[` `]` и подерживают задание диапазанов
через дефис. `0|1|2|3|4|5|6|7|8|9`  <=>  `[0-9]`. Символьный класс можно инвертировать, начав его с `^` 
Для некоторых диапазонов существуют специальные обозначения

Символ | Эквивалент | Описание
--- | --- | ---
\d | [0-9] | Цифровой символ
\D | [^0-9] | Нецифровой символ
\s | [ \f\n\r\t\v] | Пробельный символ
\S | [^ \f\n\r\t\v] | Непробельный символ
\w | [a-zA-Z] | Буквенный (латинский) или цифровой символ или знак подчёркивания
\W | [^a-zA-Z] | Любой символ, кроме буквенного или цифрового символа или знака подчёркивания
   | [А-Яа-яЁё] | Буквенный символ (кирилица)
 . |            | Любой символ


Якорь | Описание
--- | --- 
\^ | Начало строки
\А | Начало текста
\$ | Конец строки
\Z | Конец текста
\b | Граница слова
\B | Не граница слова
[Якорь в морфологии](https://regex101.com/r/bN6a8X/1)

Утверждения

Код | Описание
--- | ---
?= | Вперед смотрящее
?! | Отрицательное вперед смотрящее
?<= | Назад смотрящее
?!= или ? | Отрицательное назад смотрящее


[Практикум якоря и утвеждения](https://regex101.com/r/QHRLg4/1)